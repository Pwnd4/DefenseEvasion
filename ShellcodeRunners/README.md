# OPSEC-improved Shellcode Runners
The classical method of shellcode injection - the `VirtualAllocEx`/`WriteProcessMemory`/`CreateRemoteThread` pattern - has numerous OPSEC disadvantages and is nowadays often unlikely to be successful against modern defense mechanisms. In this repo some techniques for OPSEC-improved shellcode runners are tried out and combined. Of course, none of these general techniques were discovered by me. I am just recombining and playing around with some of them as part of my personal learning process and to address some specific issues I came across.

## DInvokeOrdinalsQueueUserApc
[This shellcode runner](https://github.com/Pwnd4/DefenseEvasion/blob/main/ShellcodeRunners/DInvokeOrdinalsQueueUserApc.cs) (based on code by [jfmaes](https://gist.github.com/jfmaes)) loads shellcode from a webserver, spawns a (hidden) msedge.exe process in a suspended state (`CreateProcess`) and injects the shellcode into it's memory. Then queues the APC on it's primary thread (`QueueUserAPC`) and resumes the thread to execute the shellcode (`ResumeThread`).     
This shellcode runner was specifically built to bypass three MS Office-related [Attack Surface Reduction (ASR)](https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/attack-surface-reduction?view=o365-worldwide) rules in one fell swoop when launched from a VBA macro: *"Block win32 APIs from Office"*, *"Block Code Injection from Office"* and *"Block all Office applications from creating child processes"*. While working on it, I found out that Microsoft seemingly whitelisted msedge.exe from the latter rule (which is the case for some other programs too). I guess that is because otherwise you could not open a webpage by clicking on a link in a MS Office document. So you can simply bypass the third rule by injecting into msedge.exe, no need for LOLBAS techniques (which is also a possible approach, see the [Defense Evasion Mindmap](https://github.com/Pwnd4/DefenseEvasion/blob/main/CobaltStrikeDefenseEvasion.pdf)) or spoofing the parent PID. I implemented PPID spoofing in the code anyway because without PPID spoofing, when the victim closes WinWord.exe, the msedge.exe process gets orphaned. This does not kill our Beacon but could look suspicious to the defenders.  
The shellcode runner can of course also be useful for other scenarios, apart from bypassing ASR rules.

#### OPSEC Problems and Solutions addressed in this shellcode runner:
1. **Problem: P/Invoke usage gets detected**. When writing a shellcode runner in C# we use managed code to access the unmanaged code of Win32 APIs which are written in C/C++. This is quiet some extra work when compared to C++ and often requires to [P/Invoke](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke) manually within our code to translate the C data types to C# data types and import the Win32 APIs. Tools such as PEstudio can inspect a compiled .NET assembly and identify suspicious-looking P/Invoke usage.  
**Solution:** Use Dynamic Invoke as a replacement for P/Invoke (either the original [D/Invoke](https://github.com/TheWover/DInvoke) or Rastamouse's [minimalistic fork](https://github.com/rasta-mouse/DInvoke/) containing only the core `DynamicInvoke` and `ManualMap` functionality, which lowers the detection surface for AV). Doing so we can invoke unmanaged code without P/Invoke, making the API imports invisible for tools such as pestudio. Note: D/Invoke comes as a DLL that you have to first build and then use as a reference in your C# project, when compiling this shellcode runner.
2. **Problem: API calls get detected**. The well-known calls to the `OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory` and `CreateRemoteThread` Win32 APIs are synonymous with process injection and will therefore in many cases raise alarms.  
**Solution:** To replace `CreateRemoteThread` we spawn the process in a suspended state and then queue the APC on it's primary thread (`QueueUserAPC`). Finally we resume the thread to execute the shellcode (`ResumeThread`). 
3. **Problem: API names get detected**. Even if we avoid the usage of P/Invoke and the most suspicious Win32 APIs altogether, the use of APIs in general could still be revealed by an AV's string analysis of the binary file. This is because the well-known API names are used to import and to call them.  
**Solution:** To call an API without using its name, we replace it with it's ordinal. The ordinal is a number that identifies an exported function in the regarding DLL. Several D/Invoke methods will take an ordinal rather than a string, e.g. `GetLibraryAddress` has an overload that will take an ordinal. Keep in mind that the ordinal numbers could differ between different versions of the regarding DLL. So you have to be sure which version is used on the target.
4. **Problem: API hooking by EDRs**. EDR agents like to primarily monitor the use of Windows APIs. They normally carry out their inspection in userland, which is achieved by API Hooking.  Even if we bypass all traditional AV detection, an EDR could still detect our Win32 API calls and raise an alarm.  
**Solution:** A simple solution to bypass EDR, but only sufficient in certain cases and for non-Microsoft EDR vendors, is to misuse the "Process Mitigation Policy". If the vendor's DLL is not signed by Microsoft we can, when creating the process, ask the kernel to protect us from such unsigned, therefore potentially dangerous, libraries ツ. This policy will prevent them from being loaded into the process. To achieve this the code defines the regarding attributes in the `PPROC_THREAD_ATTRIBUTE_LIST` when spawning the process. 
5. **Problem: No/limited access to Win32 APIs from JSript/VBA/VBS**. Especially when it comes to initial access through phishing it's mostly not possible to directly execute PEs. But on the other hand, more realistic ways to run code on initial access either lack access to Win32 APIs at all (like JScript) or it is often heavily restricted (like with VBA when ASR rules are applied).  
**Solution:** Keep the C# code compatible with [GadgetToJScript](https://github.com/med0x2e/GadgetToJScript). G2JS generates serialised gadgets from a .NET assembly that then can trigger .NET execution from JScript, VBScript and VBA. This can be delivered in a phishing payload, such as a VBA macro or HTA and can help to bypass certain Attack Surface Reduction (ASR) rules (e.g. "Block processes created through WMI from running" or "Prevent VBA macros from calling Win32 APIs") and application whitelisting techniques. To use an assembly with `GadgetToJScript`, it's code has to meet some specific conditions. E.g. G2JS requires the code to execute be in the constructor. Also inline declarations must be avoided. Also be aware that this kind of attack will often save to disk and you might get caught thanks to a static G2JS signature - so you might have to do carry out some obfuscation on the G2JS output.
6. **Problem: Parent process makes Beacon process look suspicious**. When using the CreateProcess API, by default, the resulting process will spawn as a child of the caller. In many cases, e.g. if your initial code executes in MS Office or other unusual process, this is highly undesirable because it would raise high severity alerts or be blocked immediately.  
**Solution:** "PPID spoofing" allows the caller to change the parent process ID for the spawned process.  So if our initial code was running in msword.exe or powershell.exe, we can spawn processes as children of a different process, such as msedge.exe.  This will cause applications such as Sysmon to log the process creation under the spoofed parent. We achieve that by passing the additional `PROC_THREAD_ATTRIBUTE_PARENT_PROCESS` attribute to the `CreateProcess` call. 

## DinvokeNtMapViewOfSection
In some aspects this shellcode runner is similar to the above `DInvokeOrdinalsQueueUserApc` but 
1. instead of Win32 APIs we use the `Nt*`Section set of lower-level native APIs. We fetch the shellcode and create a new section within our current process, then map the view of that section into memory of the current process. Next we get a handle to the target process and map the same section into it. Finally we create a new remote thread to execute the shellcode in the remote process.
2. We don't create a new process to inject into but instead find an already running process suitable for our purposes and inject into it.

#### OPSEC Problems and Solutions addressed in this shellcode runner:
1. **Problem: Suspicious `P/Invoke` usage**. See DInvokeOrdinalsQueueUserApc above.  
**Solution:** Use Dynamic Invoke as a replacement for P/Invoke. See DInvokeOrdinalsQueueUserApc above.
2. **Problem: Using Win32 APIs generally under close surveillance**. Using Win32 APIs could be subject to increased monitoring by defense mechanisms, even when avoiding the "usual suspects" like `CreateRemoteThread`.  
**Solution:** Using low-level native APIs instead of Win32 APIs can lower our profile. We fetch the shellcode and create a new section within our current process with `NtCreateSection`, then map the view of that section into the memory of the current process as RW with `NtMapViewOfSection` and copy the shellcode into the memory of our own process. Next we get a handle to the target process and map the same section into it, again using `NtMapViewOfSection` but this time setting RX privileges. Finally we create a new remote thread with `NtCreateThreadEx` to execute the shellcode in the remote process.
3. **Problem: No/limited access to Win32 APIs from JSript/VBA/VBS**. We have to execute from code which has no or very resticted access to Win32 or native APIs (JScript, VBA). See `DInvokeOrdinalsQueueUserApc` above.  
**Solution:** Keep the C# code compatible with [GadgetToJScript](https://github.com/med0x2e/GadgetToJScript). See `DInvokeOrdinalsQueueUserApc` above.  
4. **Problem: Office applications can not spawn child processes**. The ASR rule *"Block all Office applications from creating child processes"* forbids us to spawn as a child of the caller when executing from MS Office.  
**Solution:** As we inject into an existing remote process instead of creating a new one, the new thread running our shellcode will appear to be completely unrelated to the MS Office process it originated from. Please note that when injecting into an existing process instead of creating a new one, we can neither spoof the PPID nor use the "Process Mitigation Policy" (to block DLLs) as both settings have to made at the time the process is created (AFAIK).
